
input {
  beats {
    port => 5044
    host => "0.0.0.0" # specify host whitelist
  }   
}

filter {
  grok {
    patterns_dir => ["logs-test/patterns"]
    # field to parse
    match => {"message" => [
      "%{COMMON_LOG} %{WORD:type}\|%{NUMBER:status:int}\|%{USERNAME:user}\|%{IP:ip}",
      "%%{COMMON_LOG} %{WORD:type}\|%{NUMBER:duration:float}\|%{DATA:action}\|%{WORD:status:int}\|%{USERNAME:user}",
      "(?m)%{COMMON_LOG} %{DATA:error_message}\|%{GREEDYDATA:stacktrace}"
      ]
    }
  }

  mutate {
    remove_field => ["message", "input", "prospector", "@version", "ecs", "host"]
    rename => {"@timestamp" => "processTime"}
  }

  if ![type] { # if type field doesn't exists, do the mutate
    mutate { # if type field doesn't exits, I know it's a Java error
      add_field => {"type" => "JAVA_ERROR"}
    }
  }

  if [type] == "LOGIN" {
    if [status] > 300 {
      mutate { add_field => {"loginSuccessfull" => false} }
    } else {
      mutate { add_field => {"loginSuccessfull" => true} }
    }

    translate {
      field => "status"
      destination => "status_meaning"
      dictionary => {
        "200" => "Login Correct"
        "201" => "Login Correct with Multiple Attempts"
        "202" => "Login Correct with Password changed"
        "204" => "Automated Login"
        "250" => "Login with Cookie"
        "150" => "Impersonated User"
        "400" => "User Blocked"
        "404" => "User Not Found"
        "500" => "Internal Server Error"
      }
    }

    geoip {
      source => "ip"
    }
  }

  date { # by default it overrides @timestamp field, we can use target option to save this date in a custom field
    match => ["date", "YYYY-MM-dd HH:mm:ss"]
  }
}

output {
  stdout {}
}
